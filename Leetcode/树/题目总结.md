# 二叉树的下一个节点

>给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。

解法:  
如果此结点有右子树，则遍历到最左结点；如果此结点没有右子树，则分类讨论

1) 此结点是其父节点的左结点，则直接返回父节点
2) 此节点是其父节点的右结点，则找到是其左结点的结点，返回父结点的父结点

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#         self.father = None
class Solution(object):
    def inorderSuccessor(self, q):
        if q.right:
            q = q.right 
            while q.left:
                q = q.left
            return q
        else:
            if q.father.left = q:
                return q.father
            else:
                while q.father and q.father.right == q:
                    q = q.father
                return q.father
```

# 重建二叉树
>给出二叉树的前序和中序遍历, 重建二叉树:  
>输入:  
前序遍历：[3, 9, 20, 15, 7]  
中序遍历：[9, 3, 15, 20, 7]  
返回：  
[3, 9, 20, null, null, 15, 7, null, null, null, null]

解法:

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        if not preorder or not inorder:
            return None
        root = TreeNode(preorder[0])
        idx = inorder.index(preorder[0])

        root.left = self.buildTree(preorder[1 : idx+1], inorder[ : idx])
        root.right = self.buildTree(preorder[idx + 1: ], inorder[idx + 1: ])

        return root
```
