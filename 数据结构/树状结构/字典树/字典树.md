# 字典树

## 结构
Trie 树，也叫“字典树”，是多分支树形结构，用来解决在一组字符串集合中快速查找某个字符串的问题

- 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。
- 从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串。
- 每个字符串的公共前缀作为一个字符节点保存
- 每个节点结束的时候用一个标记表示结束（True or False），从根节点到标记所经过的节点对应一个英文单词

## 性质

> a collection S of s strings of total length n from an alphabet Σ has the following properties

- Trie树的高度等于最长字符的长度
- 每个节点的孩子最多是 |Σ| (空间换时间思想)
- 节点数目最多是 n + 1
- Trie 树有 s 个叶子
- 采用节点打标记的方法确定是否为字符串
- 插入、查找的复杂度均为O(n)，n为字符串长度

## 核心思想：
空间换时间，利用字符串的公共前缀来降低查询的时间开销

## 基本操作  
[参考1](https://zhuanlan.zhihu.com/p/57342852)
[参考2](https://www.jianshu.com/p/0353a95ccaa0)
[参考3](https://my.oschina.net/u/158589/blog/61037)

### 插入

从根结点遍历

- 键存在。沿着链接移动到树的下一个子层，算法继续搜索下一个键字符。
- 键不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配。

重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成

复杂度分析

- 时间复杂度：O(m)，其中 m为键长，在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 m 次操作
- 空间复杂度：O(m)，最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 m个结点，使用 O(m) 空间

### 查找

从根遍历：

- 键不存在。返回False
- 键存在，遍历到最后
    - 标记是True，返回True
    - 标记是False，返回False

复杂度分析

- 时间复杂度 : O(m)，算法的每一步均搜索下一个键字符。最坏的情况下需要 mm 次操作
- 空间复杂度 : O(1)

### 查找前缀

从根遍历 Trie 树，直到键前缀中没有字符，或者无法用当前的键字符继续 Trie 中的路径。与上面提到的“搜索键”算法唯一的区别是，到达键前缀的末尾时，总是返回 true

复杂度分析

- 时间复杂度 : O(m)
- 空间复杂度 : O(1)

