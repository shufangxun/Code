## Leetcode

- [x] 最小覆盖子串
- [x] 至多包含两个不同字符的最长子串

## 滑动窗口

概述  

滑动窗口用以解决数组/字符串的子元素问题，一般涉及双指针，可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度

操作  

右边滑动进入，左边根据条件操作

模板  

１. 无重复字符的最长子串
```python
class Solution:
    def lengthOfLongestSubstring(self, s):
        from collections import defaultdict
        lookup = defaultdict(int)
        start, end = 0, 0
        max_len = 0
        counter = 0
        while end < len(s):
            if lookup[s[end]] > 0:
                counter += 1
            lookup[s[end]] += 1
            end += 1
            while counter > 0:
                if lookup[s[start]] > 1:
                    counter -= 1
                lookup[s[start]] -= 1
                start += 1
            max_len = max(max_len, end - start)
        return max_len
```

２. 最小覆盖子串

```python
class Solution:
    def minWindow(self, s: 'str', t: 'str') -> 'str':
        from collections import defaultdict
        lookup = defaultdict(int)
        for c in t:
            lookup[c] += 1
        start, end = 0, 0
        min_len = len(s)
        counter = len(t)
        res = ""
        while end < len(s):
            if lookup[s[end]] > 0:
                counter -= 1
            lookup[s[end]] -= 1
            end += 1
            while counter == 0:
                if end - start < minlen:
                    min_len = end - start
                    res = s[start:end]
                if lookup[s[start]] == 0:
                    counter += 1
                lookup[s[start]] += 1
                start += 1
        return res
```


３. 至多包含两个不同字符的最长子串

```python
class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
        from collections import defaultdict
        lookup = defaultdict(int)
        start = 0
        end = 0
        max_len = 0
        counter = 0
        while end < len(s):
            if lookup[s[end]] == 0:
                counter += 1
            lookup[s[end]] += 1
            end +=1
            while counter > 2:
                if lookup[s[start]] == 1:
                    counter -= 1
                lookup[s[start]] -= 1
                start += 1
            max_len = max(max_len, end - start)
        return max_len
```