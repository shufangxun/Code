**题目**  

反转一个单链表。

**样例**:

>输入: 1->2->3->4->5->NULL  
输出: 5->4->3->2->1->NULL

**算法**

**1.迭代法**

- 设置当前结点和前驱结点: cur, pre
- 首先保存后继结点: nex = cur.next
- 然后将当前结点的指针指向前驱结点: cur.next = pre
- 最后结点后移: 当前结点先后移,然后是前驱结点
- 注意检查是否为空

**复杂度分析**  
- 时间复杂度：O(n)
- 空间复杂度: O(1)

**2.递归法**  
>递归翻转后 n-1 个节点, 并将当前节点接在后 n-1 个节点后面 
- 函数作用: 翻转链表，并返回新链表的头节点，也就是原链表的尾节点。
- 递归处理: 翻转 head->next 为头节点的链表, 并得到原链表的尾节点 tail, 此时 head->next 是新链表的尾节点
- 当前节点接入: 令 head->next 的 next 指针指向head，并将 head->next 指向 None 即可将整个链表翻转，且新链表的头节点是 tail。

**复杂度分析**
- 时间复杂度：O(n)
- 空间复杂度: O(n)


[Reference](https://leetcode-cn.com/articles/reverse-linked-list/)